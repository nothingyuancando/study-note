## 好的关系设计的特点

### 设计选择：更大的模式

### 设计选择：更小的模式

#### 函数依赖

* ***函数依赖：***在一个表里面，属性X可以映射到属性Y，也就是说知道了X就能确定Y，称X为决定因素。
  举栗子🌰：有一个关系模式S(Sno,Sname,Sage)
  如果知道了一个学生的学号Sno，那我就能确定他的姓名Sname和年龄Sage。

  当然，如果你强制规定学生姓名不能重复。那么，知道了一个学生的姓名也是可以确定其他属性的，这也是满足函数依赖关系的。

  ![pic.png](imgs/8.png)

  

​			***注：***平凡函数依赖和非平凡函数依赖在这里不做解释

* ***完全函数依赖和部分函数依赖***
  直接举栗子🌰：有一个关系模式S(Sno,Sname,Cno,Grade)

  * **完全函数依赖：**如果我想知道某位学生的某一门课的成绩Grade，那我必须得同时知道他的学号Sno和课程号Cno。
    但如果我只知道一部分信息，比如他的Sno或者Cno可以吗？答案是不行的！此时称Y[Grade]完全依赖于X[Sno,Cno]。

  ![pic.png](imgs/9.png)

  * **部分函数依赖：**如果我想知道某位学生的姓名Sname，那我知道他的学号Sno就可以了。也就是说Y[Sname]只函数依赖于X[Sno,Cno]中的子集x[Sno]，此时称Y部分函数依赖于X。

    ![pic.png](imgs/10.png)

* ***传递函数依赖***
  直接讲人话🌰：有一个关系模式S(Sno,Sdept,Mname)
  如果我知道了一个学生的学号Sno，那我就能知道他所在的系Sdept。(因为理论上一个学生只属于一个系)
  如果我知道了某一个系Sdept，那么我就能知道这个系的系主任的姓名Mname。
  也就是说，我知道了一个学生的学号Sno，其实我就知道了他所在系的系主任的姓名Mname。但这个过程中，他们是不存在直接函数依赖的，我需要通过系名称Sdept作为一个桥梁去把二者联系起来的。

![pic.png](imgs/11.png)

#### 无损分解

***概念***：无损分解指的是对关系模式分解时，原关系模型下任一合法的关系值在分解之后应能通过自然联接运算恢复起来。反之，则称为有损分解。

设R是一个关系模式，F是R上的一个依赖集，R分解为关系模式的集合p={R1(U1),R2(U2),....,Rn(Un)}。如果对于R中满足F的每一个关系r，都有r=πR1(r)⋈πR2(r)⋈..πRn(r)则称分解相对于F是无损连接分解，否则有有损连接。

***怎么测试是否为无损连接***

* 构造一个k行n列的表格，每列对应一个属性Aj（j=1,2,..n),每行对应一个模式Ri(Ui)=(i=1,2...k)的属性集合。如果Aj在Ui中，那么表格的第i行j列处添上记号aj，否则添上记号bij.
* 复查F的每一个函数依赖，并且修改表格中的元素，直到表格不能修改为止。
  取F中函数依赖X->Y,如果表格中总有两行在X分量上相等，在Y分量上不相等，则修改Y分量的值，使这两行在Y分量上相等，有以下两种情况：
  * 如果Y分量中有一个是aj，则另一个也变成aj
  * 如果Y分量中没有aj，就用下标较小的bij替换另一个符号。

* 修改结束后一行全是a，则p相对于F是无损分解。

## 原子域和第一范式

在关系模型中，我们将属性不具有任何子结构这个思想形式化。一个域是**原子的**，如果该域的元素被认为是不可分的单元。我们称一个关系模式R属于**第一范式**，如果R的所有属性的域都是原子的。

* 名字的集合是一个非原子值的例子。例如，如果关系employee的模式包含一个属性children，它的域元素是名字的集合，该模式就不属于第一范式。
* 组合属性，包含子属性也具有非原子域。
* 假定整数是原子的，那么整数的集合是一个原子域；然而所有整数集的集合是一个非原子域。

## 使用函数依赖进行分解

* 一般情况下，我们用**α**表示属性集，r(R)指关系模式。我们用表示法r(R)表示该模式是关系r的，R表示属性集。
* 一个关系模式是一个属性集，但并非所有的属性集都是模式。
* 当属性集是一个超码时，我们用K表示它。超码属于特殊的关系模式，使用术语“K是r(R)的超码”
* 一个关系在任意给定时间都有特定的值，我们将那看作一个实例并使用术语“**r**的实例“。

### 码和函数依赖

* 一个数据库对现实世界中的一组实体和联系建模。在现实世界中，数据上通常存在各种约束（规则）。
* 一个关系的满足所有这种现实世界约束的实例，称为关系的**合法实例**；在一个数据库的合法实例中所有的关系实例都是合法实例。
* **超码**可以唯一标识关系中一条元组的一个或多个属性的集合。在此重新表述：

![pic.png](imgs/12.png)

* 我们以两种方式使用函数依赖：
  * 判断关系的实例是否满足给定函数依赖集F。
  * 说明合法关系集上的约束。因此，我们将只关心给定函数依赖集的那些关系实例。如果我们希望值考虑模式R上满足函数依赖集F的关系，我们说F在r(R)上**成立**。
* ![pic.png](imgs/13.png)
* 我们使用**F^+^**表示F集合的闭包。

### Boyce-Code范式

* 具有函数依赖集F的关系模式R属于BCNF（Boyce-Code Normal Form,BCNF,Boyce-Code范式）的条件是，对**F^+^**中所有形如α -> β的函数依赖（其中α ⊆ R,且β⊆R），下面至少有一项成立：
  * α -> β 是平凡的函数依赖即β⊆α
  * α是模式R的一个超码
  * 一个数据库设计属于CBCNF的条件是构成该设计的关系模式集中的每个模式都属于BCNF。

### BCNF和保持依赖

***保持依赖的判断***

如果F上的每一个函数依赖都在其分解后的某一个关系上成立，则这个分解是保持依赖的（这是一个充分条件）。
**如果上述判断失败**，并不能断言分解不是保持依赖的，还要使用下面的通用方法来做进一步判断。
该方法的表述如下：

```sql
算法二：
对F上的每一个α→β使用下面的过程：
result:=α;
while(result发生变化)do
    for each 分解后的Ri
        t=(result∩Ri)+ ∩Ri
        result=result∪t
1234567
```

这里的属性闭包是在函数依赖集F下计算出来的。如果result中包含了β的所有属性，则函数依赖α→β。分解是保持依赖的当且仅当上述过程中F的所有依赖都被保持。

### 第三范式

​	第三范式(Third Normal Form,3rd NF)就是指表中的所有数据元素不但要能唯一地被主关键字所标识,而且它们之间还必须相互独立,不存在其他的函数关系。也就是说，对于一个满足2nd NF 的数据结构来说，表中有可能存在某些数据元素依赖于其他非关键字数据元素的现象,必须消除。

#### 第一范式

**表中无表**，即每个属性都是不可分割的。

不满足第一范式的数据库就不是关系型数据库，所以说能在MySql建立的表肯定满足第一范式。

![pic.png](imgs/14.png)

其中 联系方式 这个属性还能继续被分割，这样无法建立MySql表。

#### 第二范式

**满足第一范式基础上，非主属性必须完全依赖于主属性。**

即主键的整体才能确定一个非主属性。

如果主键的部分属性就确定了一个非主属性就不满足第二范式。

有一张表 R (**学号，课程号**，成绩，姓名， 老师，老师职称)，标红的是主键，其余的是非主键，又叫做非主属性。

下面我们来观察一下，主键和非主键之间的关系。

第一步，我们先观察成绩：

(**学号，课程号**) → (成绩)。
我们发现无论是学号还是课程号都无法单独确定成绩情况，只有知道了一个人的学号和课程号才能确定有效的成绩。

学号和成绩必须作为一个整体才能决定成绩。

此时我们称成绩完全函数依赖于（**学号，课程号**）。

记作：X（**学号，课程号**）（f）$\rightarrow$Y（成绩）这里的f是full全部的意思。

接着你可以自行判断，教师和教师职称都满足完全函数依赖。

第二步，我们再观察姓名：

我们可以发现其实（**学号**）→姓名，意思是就是主属性的其中的某一部分属性（**学号**）就可以确定姓名。

所以我们称姓名部分函数依赖于（**学号，课程号**），记作

X（**学号，课程号**）（p）$\rightarrow$Y（姓名），这里的p就是part一部分。

最后我们回到第二范式：

非主属性必须完全依赖于主属性，很明显这张表并不满足第二范式。因为姓名部分函数依赖于主属性。

那么，不满足第二范式的表会存在什么弊端呢？

比如说我们现在要新增一个学生，该学生还没有选课，因此就不能新增。课程号是关键码，又必须添加，产生了冲突。这是因为知道学号，姓名就确定一个学生，并不需要课程号。

因此我们必须将消除表中对主属性部分依赖的非主属性，这里指的就是姓名。

C（**学号，课程号**，成绩，教师，教师职称）

S（**学号**，姓名）

#### 第三范式

**满足第二范式基础上，且消除对主属性的传递依赖。**

通过观察我们可以发现（学号，课程号）之所以能决定教师职称并不是直接得出来的，是因为我们知道了教师才知道教师职称。

即X（**学号，课程号**）→Y(教师)，Y(教师)→Z (教师职称) 导致的X（**学号，课程号**）→Z（教师职称）。

我们称教师职称是传递依赖于（**学号，课程号**）。

存在传递依赖也有弊端，比如：

老师职称改变了，要修改很多条数据。（修改异常）

没人选某个老师的课时候，该老师的职称记录就会被全部删除。（删除异常）

新来老师还没有定教哪门课，教师职称不知该保存到什么地方。（插入异常）

所以，我们必须消除传递依赖。具体做法就是消除传递依赖的非主属性：

（**学号，课程号**，成绩，教师）

（**教师**，教师职称）

### 更高的范式

## 函数依赖理论

### 函数依赖

**定义**：设 **R(U)** 是**属性集合 U={ A1, A2, ... , An }** 上的**一个关系模式**，X, Y 是 U 上的两个子集，若对 R(U) 的任意一个可能的关系 r ，r 中不可能有两个元组满足在 X 中的属性值相等而在 Y 中的属性值不等，则称 “ X 函数决定 Y ” 或 “ Y函数依赖于X ” ，记作 X→Y 。

**白话**：在一个**关系 R** 中，属性（组） Y 的值是由属性（组） X 的值所决定的 。又可以说，在关系 R 中，**若两个元组的 X 属性值相同，那么这两个元组的 Y 属性值也相同**。

为什么叫做**函数**依赖？ 函数的定义：对于定义域中任意 x ，有且只有一个 y 与之对应。 属性之间的依赖：对于相同的 X 属性值，有且只有一个 Y 属性值与之对应。

**本质**：函数依赖的本质就是反应了 一个关系中**属性之间**的**约束关系**，或者**依赖关系**。函数依赖是一种数据依赖。

**举例**：

> 1. U = { 学号，姓名，年龄，专业 }
>
> {学号} → { 姓名，年龄，专业 }

**函数依赖** 分为 **非平凡函数依赖** 和 **平凡函数依赖**。 **非平凡函数依赖**：对 X→Y ，但 Y⊄X，则称 X→Y 为非平凡的函数依赖。也就是说 X 决定 Y，但是 Y 不在 X 中，这种叫做非平凡函数依赖。否则就是平凡函数依赖。

### 完全函数依赖和部分函数依赖

**定义**：在关系 R(U) 中， 若 X→Y，且对于 X 的任何真子集 X‘ 都有 X’ ↛ Y，则称 Y 完全函数依赖于 X，记为：X→(f)Y 。否则称 Y函数部分依赖于 X，记为 X→(p)Y 。

**白话**：完全函数依赖就是说 **属性组 X 的所有属性一起（即完全）才能决定属性 Y**，去掉任何一个属性都不行。相反的，部分函数依赖就是说 属性组 X 中的 部分属性就可以决定 Y ，用不着全部。

**Insight**：如果 属性（组）Y 部分函数依赖于 属性组 X，则说明属性组 X 中存在着对属性（组） Y 的**非受控冗余**。在设计数据库时应避免这种情况。（对应着 2NF ）。

**举例：**

> U = {学号，姓名，年龄，班号，班长，课号，成绩 }
>
> {学号，课号} →f U
> { 学号，课号 } →p { 姓名，年龄 }
> { 学号，课号 } →p { 成绩 }

**解释**：单个学号可以决定性别和年龄，单个学号就可以决定成绩。因此 姓名，年龄姓名，年龄 和 成绩成绩 对 学号，课号学号，课号 是部分函数依赖。

### 传递函数依赖

**定义**：在 R(U) 中，若 ，X→Y，Y→Z ，**且 Y⊄X，Z⊄Y，Z⊄X，Y↛X**，则称 Z 传递函数依赖于 X 。

**白话**：如果 X 函数决定 Y，Y 函数决定Z，且 Y、Z 都不包含于 X，Z 不包含于 Y ，Y 不能决定 X，则称 Z 传递函数依赖于 X。 **注意！**：若 ，X→Y，Y→Z，可以得到X→Z，但 不能说 Z 传递函数依赖于 X。

**Insight**：传递函数依赖存在着非受控冗余。

**举例：**

> 学生( 学号，姓名，系号，系主任 )
>
> {学号} → { 系号 }
> {系号} → { 系主任 }
> {学号} → { 系主任 }
> “系主任” 是传递依赖于 “学号” 的。

### 与函数依赖相关的概念

**候选键**

**定义**：设 K 为 R(U) 中的属性或属性组合，若 K→(f)U，则称 K 为 R(U) 上的候选键。

**白话**：对于关系 R(U) 中的属性（组）K，如果 U 完全函数依赖于 K，即 K 中的所有属性一起才能决定 U，则称 K 为 R(U) 的候选键。

**主键**

如果有多个候选键，则可以选择任一候选键作为**主键**。

**主属性**

包含在任一候选键中的属性称为**主属性**，其他属性称为**非主属性**。

**外来键**

若 R(U) 中的属性（组）X 不是 R 的候选键，却是另一关系 S(U) 的候选键，则称 X 为 R(U) 的外来键，简称**外键**。

**白话**：一个关系的外键是另一关系的候选键。

**逻辑蕴含**

**定义**：设 **F** 是关系 R(U) 中的一个**函数依赖集合**，X、Y 是 R 的属性子集，如果能从 F 这个函数依赖集合中推导出 X→Y，则称 F 逻辑蕴含 X→y，或者说 X→y 是 F 的逻辑蕴含。记作 F⊨X→Y。

**闭包**

**定义** ：被 F 逻辑蕴含的所有函数依赖集合称为 F 的闭包，记作 F+。

**白话**：也就是说，能从 函数依赖集 F 中推导出的所有函数依赖组成的集合，称为 F 的闭包。（学过泛函的话应该能感觉到有种完备的概念）。

如果 F+=F，则称 F 是一个 全 函数依赖族。（函数依赖完备集）。

### 函数依赖的 Armstrong 公理及其引理

设 F 为 R(U) 的一组函数依赖，记为 R(U, F) 。

#### 函数依赖的 Armstrong 公理

**自反律**

若 Y⊆X⊆U，则 X→Y 被 F 逻辑蕴含。

白话：若 属性集 Y 包含于 X，X 包含于 U，则 X→Y 。也就是说 如果属性集 Y 属于 X，则 X 可以决定 Y，又可以说 **属性集 X 可以决定 他的属性 子集**。（平凡函数依赖）

**增广律**

若 X→Y∈E，且 Z⊆U，则 XZ→YZ 被 F 逻辑蕴含。

**白话**：如果 X→Y 在 F 这个函数依赖集合中，另一属性(组) Z 是属性集 U 中的元素，那么从 F 中可以推导出 XZ 函数决定 YZ。

**传递律**

若 X→Y∈F，且 Y→Z，则 X→Z 被 F 逻辑蕴含。

#### 函数依赖的 Armstrong 的引理

**引理1**

* **合并律:**若 X→Y 且 X→Z，则 X→YZ。 证明：根据**增广律**可以得到 X→XY， XY→YZ，再根据**传递律**得到，X→YZ。
* **伪传递律:**若 X→Y 且 WY→Z，则 XW→Z。 证明：证明方法依然是 增广律 和 传递律。
* **分解律:**若 X→Y 且 Z⊆Y，则 X→Z。 证明：根据自反律可以得到 Y→Z，再根据传递律，得证 X→Z。

**引理2**

* 如果 A1，A2，... ，An是属性，则 X→A1....An 当且仅当对每个 Ai 有 X→Ai(1<=i<=n)

**属性集闭包和引理3**

* **属性（集）闭包定义：**对 R(U, F) ，X⊆U,U=A1,A2,....,An，令： X~F~^+^ = Ai 用 armstrong 三个公理 可从 F 导出 X→Ai ，称  X~F~^+^为 X 关于 F 的属性（集）闭包。

* **区分：** 闭包和属性（集）闭包： 闭包指的是 F的闭包，该集合包含的元素是**函数依赖**。 属性集闭包是 X属性(集) 关于 F 的属性（集）闭包，该集合包含的元素是**属性**。

* **引理3**若 从 F 这个函数依赖集合中可以用 Armstrong 公理 导出 X→Y，当且仅当 Y⊆X~F~^+^。

* **解释**：只有 Y 这个属性 在 X 关于 F 的属性(集)闭包中，才能推出 �→�，只要能推出 X 决定 Y，那 Y 一定在 X 关于 F 的属性(集)闭包中。

**覆盖 和 引理4、5**

* **覆盖：**定义：对 R(U) 上的两个函数依赖集合 F、G，如果 F+=G+，则称 F 和 G 也是等价的，也称作 F 覆盖 G 或者 G 覆盖 F。

* **引理4：**F+=G+⇔F⊆G+∧G⊆F+

* **引理5:**每个函数依赖集 F 可被一个 其右端至多有一个属性的函数依赖集 G 覆盖。

**最小覆盖**

* **最小覆盖**

F 满足：

1. F 中每个函数依赖的右边部分都是单个属性；
2. 对任何 X→A∈F，有 F - X→A不等价于 F；
3. 对任何X→A∈F，Z⊂X，( F- X→A)∪Z→A 不等价于F。

则 F 为 **最小覆盖** 或者 **最小依赖集**。

**解释：** 对于第 2 点，如果去掉 X→A 这个函数依赖，那么从 F 中不能推导出 X→A ，也就是说 F 中的每一个函数依赖都是必需的，一个不能少。 对于第 3 点，Z 是 函数依赖的 左边部分 的一个子集，如果去掉 X→A 这个函数依赖，加上 X 子集 Z→A 的依赖依然不等价于F，即 X→A是不能由 Z→A 代替的。

**定理：**每个函数依赖集 F 都有等价的最小覆盖 F‘。

### 正则覆盖

### 无损分解

### 保持依赖

## 分解算法

### BCNF分解

### 3NF分解

### 3NF算法的正确性

### BCNF和3NF的比较

## 使用多值依赖的分解

### 多值依赖

### 第四范式

### 4NF分解

## 更多的范式

## 数据库设计过程

### E-R模型和规范化

### 属性和联系的命名

### 为了性能去规范化

### 其他设计问题

## 时态数据建模

